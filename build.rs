use std::env;
use std::path::PathBuf;
use std::fs;
use std::process::Command;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let package_name = env::var("CARGO_PKG_NAME").unwrap();
    let target_dir = target_dir();
    let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());
    
    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rerun-if-changed=SharedModule/src/");
    println!("cargo:rerun-if-changed=ServerModule/src/");
    println!("cargo:rerun-if-changed=ClientModule/src/");
    println!("cargo:rerun-if-changed=CustomServerModule/src/");
    println!("cargo:rerun-if-changed=build.rs");
    
    // Set build-time environment variables
    set_build_env_vars();
    
    // Generate C bindings for Unreal Engine integration
    if should_generate_bindings() {
        generate_c_bindings(&crate_dir, &package_name, &target_dir);
    }
    
    // Copy DLL to Unreal project if building for client
    #[cfg(target_os = "windows")]
    if is_client_build() {
        copy_dll_to_unreal(&target_dir, &profile);
    }
    
    // Generate SpacetimeDB module files if building for server
    if is_server_build() {
        generate_spacetimedb_files(&target_dir);
    }
    
    println!("cargo:rustc-link-search=native={}", target_dir.join("lib").display());
}

fn should_generate_bindings() -> bool {
    // Generate bindings if building for client or explicitly requested
    env::var("CARGO_FEATURE_CLIENT").is_ok() || 
    env::var("GENERATE_BINDINGS").is_ok()
}

fn is_client_build() -> bool {
    env::var("CARGO_FEATURE_CLIENT").is_ok()
}

fn is_server_build() -> bool {
    env::var("CARGO_FEATURE_SERVER").is_ok()
}

fn set_build_env_vars() {
    // Set build date
    let build_date = chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string();
    println!("cargo:rustc-env=BUILD_DATE={}", build_date);
    
    // Try to get git hash
    let git_hash = get_git_hash().unwrap_or_else(|| "unknown".to_string());
    println!("cargo:rustc-env=GIT_HASH={}", git_hash);
    
    // Set other build info
    println!("cargo:rustc-env=TARGET={}", env::var("TARGET").unwrap_or_else(|_| "unknown".to_string()));
}

fn get_git_hash() -> Option<String> {
    Command::new("git")
        .args(&["rev-parse", "--short", "HEAD"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout).ok()
            } else {
                None
            }
        })
        .map(|s| s.trim().to_string())
}

fn generate_c_bindings(crate_dir: &str, package_name: &str, target_dir: &PathBuf) {
    let bindings_dir = target_dir.join("bindings");
    fs::create_dir_all(&bindings_dir).expect("Failed to create bindings directory");
    
    let header_file = bindings_dir.join(format!("{}.h", package_name));
    
    let config = cbindgen::Config {
        autogen_warning: Some("/* Auto-generated by cbindgen - DO NOT EDIT MANUALLY */".to_string()),
        include_guard: Some("SPACETIME_MMO_TEMPLATE_H".to_string()),
        cpp_compat: true,
        documentation: true,
        documentation_style: cbindgen::DocumentationStyle::Doxy,
        language: cbindgen::Language::C,
        include_version: true,
        namespace: Some("SpacetimeDB".to_string()),
        export: cbindgen::ExportConfig {
            include: vec!["FFI*".to_string(), "spacetimedb_*".to_string()],
            exclude: vec!["Internal*".to_string()],
            ..Default::default()
        },
        enumeration: cbindgen::EnumConfig {
            enum_class: true,
            ..Default::default()
        },
        ..Default::default()
    };
    
    match cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_config(config)
        .generate()
    {
        Ok(bindings) => {
            bindings.write_to_file(&header_file);
            println!("cargo:warning=Generated C bindings: {}", header_file.display());
            
            // Generate C++ wrapper
            generate_cpp_wrapper(&header_file, &bindings_dir);
        },
        Err(e) => {
            println!("cargo:warning=Failed to generate bindings: {}", e);
        }
    }
}

fn generate_cpp_wrapper(header_file: &PathBuf, bindings_dir: &PathBuf) {
    let header_content = match fs::read_to_string(header_file) {
        Ok(content) => content,
        Err(_) => return,
    };
    
    let cpp_wrapper = format!(r#"
// Generated C++ wrapper for SpacetimeDB MMO Template
// This file provides a C++ friendly interface over the C FFI functions
#pragma once

#include <string>
#include <vector>
#include <memory>
#include <functional>

#ifdef __cplusplus
extern "C" {{
#endif

{}

#ifdef __cplusplus
}}

namespace SpacetimeDB {{

/// C++ wrapper class for easier integration with Unreal Engine
class MMOClient {{
public:
    /// Connection management
    static bool Connect(const std::string& host, uint16_t port, const std::string& dbName);
    static void Disconnect();
    static bool IsConnected();
    
    /// Authentication
    static bool RegisterUser(const std::string& username, const std::string& password, const std::string& email = "");
    static bool LoginUser(const std::string& username, const std::string& password);
    static void LogoutUser();
    
    /// Game world interaction
    static bool JoinGame(const std::string& startingZone = "default");
    static void LeaveGame();
    static bool UpdatePosition(float x, float y, float z, float yaw);
    
    /// Chat system
    static bool SendChatMessage(const std::string& message, const std::string& channel = "global");
    static bool SendWhisper(const std::string& targetPlayer, const std::string& message);
    
    /// Inventory and items
    static bool UseItem(const std::string& itemId);
    
    /// Utility functions
    static std::string GetLastError();
    static std::string GetVersion();
    
private:
    static std::string last_error_;
    static void SetLastError(const std::string& error);
}};

/// Event callback types for Unreal Engine integration
using OnConnectedCallback = std::function<void(bool success)>;
using OnPlayerJoinedCallback = std::function<void(const std::string& username, float x, float y, float z)>;
using OnChatMessageCallback = std::function<void(const std::string& sender, const std::string& message, const std::string& channel)>;
using OnErrorCallback = std::function<void(const std::string& error)>;

/// Event manager for handling SpacetimeDB events
class EventManager {{
public:
    static void SetOnConnectedCallback(OnConnectedCallback callback);
    static void SetOnPlayerJoinedCallback(OnPlayerJoinedCallback callback);
    static void SetOnChatMessageCallback(OnChatMessageCallback callback);
    static void SetOnErrorCallback(OnErrorCallback callback);
    
    /// Process pending events (call this regularly from your game loop)
    static void ProcessEvents();
    
private:
    static OnConnectedCallback on_connected_;
    static OnPlayerJoinedCallback on_player_joined_;
    static OnChatMessageCallback on_chat_message_;
    static OnErrorCallback on_error_;
}};

}} // namespace SpacetimeDB

#endif // __cplusplus
"#, header_content);
    
    let cpp_file = bindings_dir.join("spacetime_mmo_template_wrapper.hpp");
    if let Err(e) = fs::write(&cpp_file, cpp_wrapper) {
        println!("cargo:warning=Failed to write C++ wrapper: {}", e);
    } else {
        println!("cargo:warning=Generated C++ wrapper: {}", cpp_file.display());
    }
    
    // Generate Unreal Engine module files
    generate_unreal_module_files(bindings_dir);
}

fn generate_unreal_module_files(bindings_dir: &PathBuf) {
    let unreal_dir = bindings_dir.join("Unreal");
    fs::create_dir_all(&unreal_dir).expect("Failed to create Unreal directory");
    
    // Generate .uplugin file
    let uplugin_content = r#"{
    "FileVersion": 3,
    "Version": 1,
    "VersionName": "1.0",
    "FriendlyName": "SpacetimeDB MMO Template",
    "Description": "Complete MMO integration with SpacetimeDB",
    "Category": "Networking",
    "CreatedBy": "SpacetimeDB Community",
    "CreatedByURL": "https://spacetimedb.com",
    "DocsURL": "",
    "MarketplaceURL": "",
    "SupportURL": "",
    "CanContainContent": true,
    "IsBetaVersion": false,
    "IsExperimentalVersion": false,
    "Installed": false,
    "Modules": [
        {
            "Name": "SpacetimeDBMMO",
            "Type": "Runtime",
            "LoadingPhase": "Default"
        }
    ]
}"#;
    
    let _ = fs::write(unreal_dir.join("SpacetimeDBMMO.uplugin"), uplugin_content);
    
    println!("cargo:warning=Generated Unreal Engine integration files in: {}", unreal_dir.display());
}

#[cfg(target_os = "windows")]
fn copy_dll_to_unreal(target_dir: &PathBuf, profile: &str) {
    let dll_name = "spacetime_mmo_template.dll";
    let source_dll = target_dir.join(profile).join(dll_name);
    
    // Try to find Unreal project directory
    let possible_paths = vec![
        PathBuf::from("../UnrealProject/Binaries/Win64"),
        PathBuf::from("../../UnrealProject/Binaries/Win64"),
        PathBuf::from(env::var("UNREAL_PROJECT_PATH").unwrap_or_default()).join("Binaries/Win64"),
    ];
    
    for unreal_path in possible_paths {
        if unreal_path.exists() && source_dll.exists() {
            let dest_dll = unreal_path.join(dll_name);
            if let Ok(_) = fs::copy(&source_dll, &dest_dll) {
                println!("cargo:warning=Copied DLL to Unreal: {}", dest_dll.display());
                break;
            }
        }
    }
}

fn generate_spacetimedb_files(target_dir: &PathBuf) {
    let spacetimedb_dir = target_dir.join("spacetimedb");
    fs::create_dir_all(&spacetimedb_dir).expect("Failed to create SpacetimeDB directory");
    
    // Generate module metadata
    let module_metadata = r#"{
    "name": "spacetime-mmo-template",
    "version": "0.1.0",
    "description": "MMO game server built with SpacetimeDB",
    "reducers": [
        "register_user",
        "login_user",
        "join_game",
        "update_player_position",
        "send_chat_message",
        "spawn_npc",
        "attack_npc"
    ],
    "tables": [
        "user",
        "game_players", 
        "chatmessage",
        "gamesession",
        "world_chunks",
        "npcs",
        "player_inventory",
        "player_skills",
        "game_items"
    ]
}"#;
    
    let _ = fs::write(spacetimedb_dir.join("module.json"), module_metadata);
    
    println!("cargo:warning=Generated SpacetimeDB module files in: {}", spacetimedb_dir.display());
}

fn target_dir() -> PathBuf {
    if let Ok(target) = env::var("CARGO_TARGET_DIR") {
        PathBuf::from(target)
    } else {
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("target")
    }
}